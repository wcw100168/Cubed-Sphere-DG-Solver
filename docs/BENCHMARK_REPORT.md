# Cubed Sphere Solver 效能基準測試報告 (Benchmark Report)

| 更新日期 | 2026/02/01 |
| :--- | :--- |
| **測試環境** | Google Colab (Linux) |
| **硬體規格** | GPU: NVIDIA T4 / CPU: Intel Xeon |
| **比較對象** | NumPy (CPU) vs JAX (GPU) |

## 1. 測試摘要

本報告評估了求解器在不同網格解析度 ($N$) 下的效能表現。測試結果證實，隨著問題規模擴大，**JAX (GPU)** 後端的平行運算優勢呈現爆發性增長。在 $N=256$ 的高解析度模擬中，JAX 展現了驚人的 **41 倍 (40.98x)** 加速能力。

## 2. 基準測試結果 (Summary Table)

| N (Grid Size) | NumPy (s) | JAX (GPU) (s) | Speedup (x) | 備註 |
| :--- | :--- | :--- | :--- | :--- |
| **32** | 0.5254 | 18.8755 | 0.03x | GPU 初始化與編譯成本佔主導 |
| **64** | 4.2795 | 20.3440 | 0.21x | 兩者效能逐漸接近 |
| **128** | 93.4461 | 22.7631 | 4.11x | GPU 優勢開始顯現 |
| **256** | **2040.54** | **49.79** | **40.98x** | **GPU 展現壓倒性效能** |

> *註1：時間包含 JIT 編譯與資料傳輸時間，模擬真實使用情境。*
> *註2：N=256 時，NumPy (CPU) 耗時約 34 分鐘，而 JAX (GPU) 僅需不到 1 分鐘。*

## 3. 結果分析 (Performance Analysis)

### 3.1 小規模網格 ($N=32, 64$)：CPU 勝出
* **現象**：在低解析度下，JAX 顯著慢於 NumPy。
* **原因**：JAX 首次執行需要進行 XLA (JIT) 編譯，通常耗時 15~20 秒。當實際運算量極小（毫秒級）時，編譯時間成為主要瓶頸。此外，GPU 數千個核心未能被填滿，處於閒置狀態。
* **建議**：開發、除錯與單元測試建議使用 **NumPy** 後端。

### 3.2 中規模網格 ($N=128$)：GPU 優勢確立
* **現象**：JAX 開始超越 NumPy，達到約 4 倍加速。
* **原因**：運算密度足以填滿 GPU 核心，平行運算的紅利抵消了編譯成本。

### 3.3 大規模網格 ($N=256$)：GPU 宰制 (Hero Metric)
* **現象**：**JAX (50s) vs NumPy (2040s)**。GPU 提供了將近 **41 倍** 的加速。
* **原因**：
    1.  **CPU 的瓶頸**：隨著 $N$ 增加，CPU 不僅面臨運算量增加，還受限於記憶體頻寬與快取未命中 (Cache Miss)，導致執行時間呈指數級暴增（從 93s 暴增至 2040s）。
    2.  **GPU 的擴展性**：GPU 僅需線性增加時間（從 23s 增加至 50s），展現極佳的擴展性。
* **建議**：生產環境與高解析度科學模擬 **必須** 使用 **JAX** 後端。

## 4. 結論

本專案的「雙後端架構」成功涵蓋了所有使用情境：
* **NumPy**: 適合 $N < 64$ 的快速原型開發。
* **JAX**: 適合 $N \ge 128$ 的高效能運算。對於 $N=256$ 或更高的模擬，使用 JAX 是唯一可行的方案（將數十分鐘縮短為數十秒）。