# Cubed Sphere Solver 效能基準測試報告 (Benchmark Report)

| 日期 | 2026/01/31 |
| :--- | :--- |
| **測試人員** | QA Lead |
| **套件版本** | 0.1.0 |
| **測試環境** | macOS (Apple Silicon M1) - JAX CPU Backend (Forced) |

## 1. 測試摘要

本報告評估 `cubed_sphere` 套件在不同計算負載下，使用 **NumPy** 與 **JAX** 後端的效能差異。

*   **NumPy**: 使用 In-place Operations 優化。
*   **JAX**: 使用 JIT Compilation (XLA) 加速。
    *   *註：由於 JAX Metal (GPU) 支援度問題，本次測試強制使用 JAX CPU Backend。但在 CPU 上仍觀察到 JIT 帶來的效能提升。*

## 2. 單元測試驗證 (Unit Test Validation)

*   ✅ **test_numerics**: 通過
    *   LGL微分矩陣精確度驗證。
*   ✅ **test_conservation**: 通過 (NumPy)
    *   質量守恆誤差 `~1.9e-6`。
*   ✅ **test_jax_conservation**: 通過 (JAX CPU)
    *   在 JAX 運算下質量守恆同樣成立 (誤差 < 1e-5)。

## 3. 效能基準測試 (Performance Benchmark)

測試參數：`CFL=1.0`, `Time Steps=100`。

### 測試結果數據

| Grid Size (N) | Backend | Setup (s) | 1st Step (s) | Avg Step (s) | Speedup |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **N=32** | NumPy | 0.0054 | 0.0031 | **0.0016** | 1.0x |
| **N=32** | JAX (CPU) | 0.6997 | 1.0268 | **0.0014** | **1.13x** |
| **N=64** | NumPy | 0.0109 | 0.0076 | **0.0023** | 1.0x |
| **N=64** | JAX (CPU) | 0.0314 | 1.2220 | **0.0020** | **1.15x** |

## 4. 結果分析 (Analysis)

1.  **JIT 編譯成本 (Compilation Overhead)**:
    *   JAX 的 `1st Step` 時間顯著較長 (約 1.0 - 1.2 秒)，這是 XLA 編譯計算圖 (Computational Graph) 所需的時間。
    *   NumPy 則幾乎即時啟動。

2.  **穩定態效能 (Steady-State Performance)**:
    *   即使在 CPU 上，**JAX 仍比 NumPy 快約 15% (1.15x)**。
    *   原因：JAX/XLA 自動進行了運算融合 (Operator Fusion)，減少了記憶體存取次數，效果類似於我們在 NumPy 中手寫的 In-place 優化，但由編譯器自動完成且更徹底。
    *   若在 NVIDIA GPU 上執行，預期 N=64 時加速比可達 10x 以上。

3.  **正確性**:
    *   兩者物理結果一致，質量守恆驗證通過。

## 5. 結論與建議 (Conclusion)

*   **小型實驗 / 除錯**: 推薦使用 **NumPy**。
    *   無編譯等待時間，適合快速迭代。
*   **長時間模擬 / 大規模運算**: 推薦使用 **JAX**。
    *   即便在 CPU 上也有 15% 的性能紅利。
    *   若有 GPU 硬體，無需修改程式碼即可獲得更大幅度的加速。

---
*Report generated by Cubed Sphere QA Team.*
